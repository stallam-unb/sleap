
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sleap.nn.paf_grouping &#8212; SLEAP  documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sleap.nn.paf_grouping</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module provides a set of utilities for grouping peaks based on PAFs.</span>

<span class="sd">Part affinity fields (PAFs) are a representation used to resolve the peak grouping</span>
<span class="sd">problem for multi-instance pose estimation [1].</span>

<span class="sd">They are a convenient way to represent directed graphs with support in image space. For</span>
<span class="sd">each edge, a PAF can be represented by an image with two channels, corresponding to the</span>
<span class="sd">x and y components of a unit vector pointing along the direction of the underlying</span>
<span class="sd">directed graph formed by the connections of the landmarks belonging to an instance.</span>

<span class="sd">Given a pair of putatively connected landmarks, the agreement between the line segment</span>
<span class="sd">that connects them and the PAF vectors found at the coordinates along the same line can</span>
<span class="sd">be used as a measure of &quot;connectedness&quot;. These scores can then be used to guide the</span>
<span class="sd">instance-wise grouping of landmarks.</span>

<span class="sd">This image space representation is particularly useful as it is amenable to neural</span>
<span class="sd">network-based prediction from unlabeled images.</span>

<span class="sd">A high-level API for grouping based on PAFs is provided through the `PAFScorer` class.</span>

<span class="sd">References:</span>
<span class="sd">    .. [1] Zhe Cao, Tomas Simon, Shih-En Wei, Yaser Sheikh. Realtime Multi-Person 2D</span>
<span class="sd">       Pose Estimation using Part Affinity Fields. In _CVPR_, 2017.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Text</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>
<span class="kn">from</span> <span class="nn">sleap.nn.config</span> <span class="kn">import</span> <span class="n">MultiInstanceConfig</span>


<div class="viewcode-block" id="PeakID"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PeakID">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">PeakID</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Indices to uniquely identify a single peak.</span>

<span class="sd">    This is a convenience named tuple for use in the matching pipeline.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        node_ind: Index of the node type (channel) of the peak.</span>
<span class="sd">        peak_ind: Index of the peak within its node type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node_ind</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">peak_ind</span><span class="p">:</span> <span class="nb">int</span></div>


<div class="viewcode-block" id="EdgeType"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.EdgeType">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">EdgeType</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Indices to uniquely identify a single edge type.</span>

<span class="sd">    This is a convenience named tuple for use in the matching pipeline.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        src_node_ind: Index of the source node type within the skeleton edges.</span>
<span class="sd">        dst_node_ind: Index of the destination node type within the skeleton edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">src_node_ind</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">dst_node_ind</span><span class="p">:</span> <span class="nb">int</span></div>


<div class="viewcode-block" id="EdgeConnection"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.EdgeConnection">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">EdgeConnection</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Indices to specify a matched connection between two peaks.</span>

<span class="sd">    This is a convenience named tuple for use in the matching pipeline.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        src_peak_ind: Index of the source peak within all peaks.</span>
<span class="sd">        dst_peak_ind: Index of the destination peak within all peaks.</span>
<span class="sd">        score: Score of the match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">src_peak_ind</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">dst_peak_ind</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">score</span><span class="p">:</span> <span class="nb">float</span></div>


<div class="viewcode-block" id="get_connection_candidates"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.get_connection_candidates">[docs]</a><span class="k">def</span> <span class="nf">get_connection_candidates</span><span class="p">(</span>
    <span class="n">peak_channel_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">skeleton_edges</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Find the indices of all the possible connections formed by the detected peaks.</span>

<span class="sd">    Args:</span>
<span class="sd">        peak_channel_inds_sample: The channel indices of the peaks found in a sample.</span>
<span class="sd">            This is a `tf.Tensor` of shape `(n_peaks,)` and dtype `tf.int32` that is</span>
<span class="sd">            used to represent a detected peak by its channel/node index in the skeleton.</span>
<span class="sd">        skeleton_edges: The indices of the nodes that form the skeleton graph as a</span>
<span class="sd">            `tf.Tensor` of shape `(n_edges, 2)` and dtype `tf.int32` where each row</span>
<span class="sd">            corresponds to the source and destination node indices.</span>
<span class="sd">        n_nodes: The total number of nodes in the skeleton as a scalar integer.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of `(edge_inds, edge_peak_inds)`.</span>

<span class="sd">        `edge_inds` is a `tf.Tensor` of shape `(n_candidates,)` indicating the indices</span>
<span class="sd">        of the edge that each of the candidate connections belongs to.</span>

<span class="sd">        `edge_peak_inds` is a `tf.Tensor` of shape `(n_candidates, 2)` with the indices</span>
<span class="sd">        of the peaks that form the source and destination of each candidate connection.</span>
<span class="sd">        This indexes into the input `peak_channel_inds_sample`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">peak_channel_inds_sample</span><span class="p">)</span>
    <span class="n">node_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">peak_channel_inds_sample</span><span class="p">,</span> <span class="n">peak_inds</span><span class="p">)</span>

    <span class="n">node_grouped_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">peak_inds</span><span class="p">,</span> <span class="n">node_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_nodes</span>
    <span class="p">)</span>  <span class="c1"># (n_nodes, (n_peaks_k))</span>
    <span class="n">edge_grouped_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">node_grouped_peak_inds</span><span class="p">,</span> <span class="n">skeleton_edges</span>
    <span class="p">)</span>  <span class="c1"># (n_edges, (n_src_peaks), (n_dst_peaks))</span>

    <span class="n">n_skeleton_edges</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">skeleton_edges</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_skeleton_edges</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">]),</span>
    <span class="p">)</span>  <span class="c1"># (n_skeleton_edges, (n_src * n_dst))</span>
    <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_skeleton_edges</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
    <span class="p">)</span>  <span class="c1"># (n_skeleton_edges, (n_src * n_dst), 2)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_skeleton_edges</span><span class="p">):</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">edge_grouped_peak_inds</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">sd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">edge_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="n">k</span><span class="p">],</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">edge_peak_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>

    <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">edge_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">edge_peak_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">edge_inds</span><span class="p">,</span> <span class="n">edge_peak_inds</span></div>


<div class="viewcode-block" id="make_line_subs"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.make_line_subs">[docs]</a><span class="k">def</span> <span class="nf">make_line_subs</span><span class="p">(</span>
    <span class="n">peaks_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">edge_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">edge_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_line_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pafs_stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create the lines between candidate connections for evaluating the PAFs.</span>

<span class="sd">    Args:</span>
<span class="sd">        peaks_sample: The detected peaks in a sample as a `tf.Tensor` of shape</span>
<span class="sd">            `(n_peaks, 2)` and dtype `tf.float32`. These should be `(x, y)` coordinates</span>
<span class="sd">            of each peak in the image scale (they will be scaled by the `pafs_stride`).</span>
<span class="sd">        edge_peak_inds: A `tf.Tensor` of shape `(n_candidates, 2)` and dtype `tf.int32`</span>
<span class="sd">            with the indices of the peaks that form the source and destination of each</span>
<span class="sd">            candidate connection. This indexes into the input `peaks_sample`. Can be</span>
<span class="sd">            generated using `get_connection_candidates()`.</span>
<span class="sd">        edge_inds: A `tf.Tensor` of shape `(n_candidates,)` and dtype `tf.int32`</span>
<span class="sd">            indicating the indices of the edge that each of the candidate connections</span>
<span class="sd">            belongs to. Can be generated using `get_connection_candidates()`.</span>
<span class="sd">        n_line_points: The number of points to interpolate between source and</span>
<span class="sd">            destination peaks in each connection candidate as a scalar integer. Values</span>
<span class="sd">            ranging from 5 to 10 are pretty reasonable.</span>
<span class="sd">        pafs_stride: The stride (1/scale) of the PAFs that these lines will need to</span>
<span class="sd">            index into relative to the image. Coordinates in `peaks_sample` will be</span>
<span class="sd">            divided by this value to adjust the indexing into the PAFs tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The line subscripts as a `tf.Tensor` of shape</span>
<span class="sd">        `(n_candidates, n_line_points, 2, 3)` and dtype `tf.int32`. These subscripts can</span>
<span class="sd">        be used directly with `tf.gather_nd` to pull out the PAF values at the lines.</span>

<span class="sd">        The last dimension of the line subscripts correspond to the full</span>
<span class="sd">        `[row, col, channel]` subscripts of each element of the lines. Axis -2 contains</span>
<span class="sd">        the same `[row, col]` for each line but `channel` is adjusted to match the</span>
<span class="sd">        channels in the PAFs tensor.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The subscripts are interpolated via nearest neighbor, so multiple fractional</span>
<span class="sd">        coordinates may map on to the same pixel if the line is short.</span>

<span class="sd">    See also: get_connection_candidates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">src_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">peaks_sample</span><span class="p">,</span> <span class="n">edge_peak_inds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">dst_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">peaks_sample</span><span class="p">,</span> <span class="n">edge_peak_inds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">n_candidates</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">src_peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">XY</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">src_peaks</span><span class="p">,</span> <span class="n">dst_peaks</span><span class="p">,</span> <span class="n">n_line_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">XY</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">XY</span> <span class="o">/</span> <span class="n">pafs_stride</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, 2, n_line_points)  # dim 1 is [x, y]</span>
    <span class="n">XY</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">XY</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># dim 1 is [row, col]</span>
    <span class="c1"># TODO: clip coords to size of pafs tensor?</span>

    <span class="n">line_subs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">XY</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">edge_inds</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">n_candidates</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_line_points</span><span class="p">]</span>
            <span class="p">),</span>
        <span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">line_subs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
        <span class="n">line_subs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, n_line_points, 3) -- last dim is [row, col, edge_ind]</span>

    <span class="n">line_subs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">line_subs</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
            <span class="n">line_subs</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
        <span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, n_line_points, 2, 3)</span>
    <span class="c1"># The last dim is [row, col, edge_ind], but for both PAF (x and y) edge channels.</span>

    <span class="k">return</span> <span class="n">line_subs</span></div>


<div class="viewcode-block" id="get_paf_lines"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.get_paf_lines">[docs]</a><span class="k">def</span> <span class="nf">get_paf_lines</span><span class="p">(</span>
    <span class="n">pafs_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">peaks_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">edge_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">edge_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_line_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pafs_stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Gets the PAF values at the lines formed between all detected peaks in a sample.</span>

<span class="sd">    Args:</span>
<span class="sd">        pafs_sample: The PAFs for the sample as a `tf.Tensor` of shape</span>
<span class="sd">            `(height, width, 2 * n_edges)`.</span>
<span class="sd">        peaks_sample: The detected peaks in a sample as a `tf.Tensor` of shape</span>
<span class="sd">            `(n_peaks, 2)` and dtype `tf.float32`. These should be `(x, y)` coordinates</span>
<span class="sd">            of each peak in the image scale (they will be scaled by the `pafs_stride`).</span>
<span class="sd">        edge_peak_inds: A `tf.Tensor` of shape `(n_candidates, 2)` and dtype `tf.int32`</span>
<span class="sd">            with the indices of the peaks that form the source and destination of each</span>
<span class="sd">            candidate connection. This indexes into the input `peaks_sample`. Can be</span>
<span class="sd">            generated using `get_connection_candidates()`.</span>
<span class="sd">        edge_inds: A `tf.Tensor` of shape `(n_candidates,)` and dtype `tf.int32`</span>
<span class="sd">            indicating the indices of the edge that each of the candidate connections</span>
<span class="sd">            belongs to. Can be generated using `get_connection_candidates()`.</span>
<span class="sd">        n_line_points: The number of points to interpolate between source and</span>
<span class="sd">            destination peaks in each connection candidate as a scalar integer. Values</span>
<span class="sd">            ranging from 5 to 10 are pretty reasonable.</span>
<span class="sd">        pafs_stride: The stride (1/scale) of the PAFs that these lines will need to</span>
<span class="sd">            index into relative to the image. Coordinates in `peaks_sample` will be</span>
<span class="sd">            divided by this value to adjust the indexing into the PAFs tensor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The PAF vectors at all of the line points as a `tf.Tensor` of shape</span>
<span class="sd">        `(n_candidates, n_line_points, 2, 3)` and dtype `tf.int32`. These subscripts can</span>
<span class="sd">        be used directly with `tf.gather_nd` to pull out the PAF values at the lines.</span>

<span class="sd">        The last dimension of the line subscripts correspond to the full</span>
<span class="sd">        `[row, col, channel]` subscripts of each element of the lines. Axis -2 contains</span>
<span class="sd">        the same `[row, col]` for each line but `channel` is adjusted to match the</span>
<span class="sd">        channels in the PAFs tensor.</span>

<span class="sd">    Notes:</span>
<span class="sd">        If only the subscripts are needed, use `make_line_subs()` to generate the lines</span>
<span class="sd">        without retrieving the PAF vector at the line points.</span>

<span class="sd">    See also: get_connection_candidates, make_line_subs, score_paf_lines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">line_subs</span> <span class="o">=</span> <span class="n">make_line_subs</span><span class="p">(</span>
        <span class="n">peaks_sample</span><span class="p">,</span> <span class="n">edge_peak_inds</span><span class="p">,</span> <span class="n">edge_inds</span><span class="p">,</span> <span class="n">n_line_points</span><span class="p">,</span> <span class="n">pafs_stride</span>
    <span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">pafs_sample</span><span class="p">,</span> <span class="n">line_subs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lines</span></div>


<div class="viewcode-block" id="score_paf_lines"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.score_paf_lines">[docs]</a><span class="k">def</span> <span class="nf">score_paf_lines</span><span class="p">(</span>
    <span class="n">paf_lines_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">peaks_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">edge_peak_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">max_edge_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the connectivity score for each PAF line in a sample.</span>

<span class="sd">    Args:</span>
<span class="sd">        paf_lines_sample: The PAF vectors evaluated at the lines formed between</span>
<span class="sd">            candidate conncetions as a `tf.Tensor` of shape</span>
<span class="sd">            `(n_candidates, n_line_points, 2, 3)` dtype `tf.int32`. This can be</span>
<span class="sd">            generated by `get_paf_lines()`.</span>
<span class="sd">        peaks_sample: The detected peaks in a sample as a `tf.Tensor` of shape</span>
<span class="sd">            `(n_peaks, 2)` and dtype `tf.float32`. These should be `(x, y)` coordinates</span>
<span class="sd">            of each peak in the image scale.</span>
<span class="sd">        edge_peak_inds_sample: A `tf.Tensor` of shape `(n_candidates, 2)` and dtype</span>
<span class="sd">            `tf.int32` with the indices of the peaks that form the source and</span>
<span class="sd">            destination of each candidate connection. This indexes into the input</span>
<span class="sd">            `peaks_sample`. Can be generated using `get_connection_candidates()`.</span>
<span class="sd">        max_edge_length: Maximum length expected for any connection as a scalar `float`</span>
<span class="sd">            in units of pixels (corresponding to `peaks_sample`. Scores of lines longer</span>
<span class="sd">            than this will be penalized. Useful for ignoring spurious connections that</span>
<span class="sd">            are far apart in space.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The line scores as a `tf.Tensor` of shape `(n_candidates,)` and dtype</span>
<span class="sd">        `tf.float32`. Each score value is the average dot product between the PAFs and</span>
<span class="sd">        the normalized displacement vector between source and destination peaks.</span>

<span class="sd">        Scores range from roughly -1.5 to 1.0, where larger values indicate a better</span>
<span class="sd">        connectivity score for the candidate. Values can be larger or smaller due to</span>
<span class="sd">        prediction error.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function operates on a single sample (frame). For batches of multiple</span>
<span class="sd">        frames, use `score_paf_lines_batch()`.</span>

<span class="sd">    See also: get_paf_lines, score_paf_lines_batch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pull out points.</span>
    <span class="n">src_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">peaks_sample</span><span class="p">,</span> <span class="n">edge_peak_inds_sample</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, 2)</span>
    <span class="n">dst_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">peaks_sample</span><span class="p">,</span> <span class="n">edge_peak_inds_sample</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, 2)</span>

    <span class="c1"># Compute normalized spatial displacement vector</span>
    <span class="n">spatial_vecs</span> <span class="o">=</span> <span class="n">dst_peaks</span> <span class="o">-</span> <span class="n">src_peaks</span>
    <span class="n">spatial_vec_lengths</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">spatial_vecs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, 1)</span>
    <span class="n">spatial_vecs</span> <span class="o">/=</span> <span class="n">spatial_vec_lengths</span>  <span class="c1"># (n_candidates, 2)</span>

    <span class="c1"># Compute similarity scores</span>
    <span class="n">line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
        <span class="n">paf_lines_sample</span> <span class="o">@</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">spatial_vecs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
    <span class="p">)</span>  <span class="c1"># (n_candidates, n_line_points)</span>

    <span class="c1"># Compute distance penalties</span>
    <span class="n">dist_penalties</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
        <span class="p">(</span><span class="n">max_edge_length</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">spatial_vec_lengths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="p">)</span>  <span class="c1"># &lt; 0 = longer than max</span>

    <span class="c1"># Compute average line scores with distance penalty.</span>
    <span class="n">mean_line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">line_scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">penalized_line_scores</span> <span class="o">=</span> <span class="n">mean_line_scores</span> <span class="o">+</span> <span class="n">dist_penalties</span>  <span class="c1"># (n_candidates,)</span>

    <span class="k">return</span> <span class="n">penalized_line_scores</span></div>


<div class="viewcode-block" id="score_paf_lines_batch"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.score_paf_lines_batch">[docs]</a><span class="k">def</span> <span class="nf">score_paf_lines_batch</span><span class="p">(</span>
    <span class="n">pafs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">peaks</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">peak_channel_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">skeleton_edges</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_line_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pafs_stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">max_edge_length_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_nodes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Create and score PAF lines formed between connection candidates.</span>

<span class="sd">    Args:</span>
<span class="sd">        pafs: The batch of part affinity fields as a `tf.Tensor` of shape</span>
<span class="sd">            `(n_samples, height, width, 2 * n_edges)` and type `tf.float32`.</span>
<span class="sd">        peaks: The coordinates of the peaks grouped by sample as a `tf.RaggedTensor` of</span>
<span class="sd">            shape `(n_samples, (n_peaks), 2)`.</span>
<span class="sd">        peak_channel_inds: The channel (node) that each peak in `peaks` corresponds to</span>
<span class="sd">            as a `tf.RaggedTensor` of shape `(n_samples, (n_peaks))` and dtype</span>
<span class="sd">            `tf.int32`.</span>
<span class="sd">        skeleton_edges: The indices of the nodes that form the skeleton graph as a</span>
<span class="sd">            `tf.Tensor` of shape `(n_edges, 2)` and dtype `tf.int32` where each row</span>
<span class="sd">            corresponds to the source and destination node indices.</span>
<span class="sd">        n_line_points: The number of points to interpolate between source and</span>
<span class="sd">            destination peaks in each connection candidate as a scalar integer. Values</span>
<span class="sd">            ranging from 5 to 10 are pretty reasonable.</span>
<span class="sd">        pafs_stride: The stride (1/scale) of the PAFs that these lines will need to</span>
<span class="sd">            index into relative to the image. Coordinates in `peaks` will be divided by</span>
<span class="sd">            this value to adjust the indexing into the `pafs` tensor.</span>
<span class="sd">        max_edge_length_ratio: The maximum expected length of a connected pair of points</span>
<span class="sd">            in relative image units. Candidate connections above this length will be</span>
<span class="sd">            penalized during matching.</span>
<span class="sd">        n_nodes: The total number of nodes in the skeleton as a scalar integer.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of `(edge_inds, edge_peak_inds, line_scores)` with the connections and</span>
<span class="sd">        their scores based on the PAFs.</span>

<span class="sd">        `edge_inds`: Sample-grouped indices of the edge in the skeleton that each</span>
<span class="sd">        connection corresponds to as `tf.RaggedTensor` of shape</span>
<span class="sd">        `(n_samples, (n_candidates))` and dtype `tf.int32`.</span>

<span class="sd">        `edge_peak_inds`: Sample-grouped indices of the peaks that form each connection</span>
<span class="sd">        as a `tf.RaggedTensor` of shape `(n_samples, (n_candidates), 2)` and dtype</span>
<span class="sd">        `tf.int32`. The last axis corresponds to the `[source, destination]` peak</span>
<span class="sd">        indices. These index into the input `peak_channel_inds`.</span>

<span class="sd">        `line_scores`: Sample-grouped scores for each candidate connection as</span>
<span class="sd">        `tf.RaggedTensor` of shape `(n_samples, (n_candidates))` and dtype `tf.float32`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function handles the looping over samples in the batch and applies:</span>

<span class="sd">        1. `get_connection_candidates()`: Find peaks that form connections.</span>
<span class="sd">        2. `get_paf_lines()`: Retrieve PAF vectors for each line.</span>
<span class="sd">        3. `score_paf_lines()`: Compute connectivity score for each candidate.</span>

<span class="sd">    See also: get_connection_candidates, get_paf_lines, score_paf_lines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_edge_length</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">max_edge_length_ratio</span>
        <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pafs</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">pafs_stride</span>
    <span class="p">)</span>

    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pafs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
        <span class="n">pafs_sample</span> <span class="o">=</span> <span class="n">pafs</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
        <span class="n">peaks_sample</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
        <span class="n">peak_channel_inds_sample</span> <span class="o">=</span> <span class="n">peak_channel_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>

        <span class="n">edge_inds_sample</span><span class="p">,</span> <span class="n">edge_peak_inds_sample</span> <span class="o">=</span> <span class="n">get_connection_candidates</span><span class="p">(</span>
            <span class="n">peak_channel_inds_sample</span><span class="p">,</span> <span class="n">skeleton_edges</span><span class="p">,</span> <span class="n">n_nodes</span>
        <span class="p">)</span>
        <span class="n">paf_lines_sample</span> <span class="o">=</span> <span class="n">get_paf_lines</span><span class="p">(</span>
            <span class="n">pafs_sample</span><span class="p">,</span>
            <span class="n">peaks_sample</span><span class="p">,</span>
            <span class="n">edge_peak_inds_sample</span><span class="p">,</span>
            <span class="n">edge_inds_sample</span><span class="p">,</span>
            <span class="n">n_line_points</span><span class="p">,</span>
            <span class="n">pafs_stride</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">line_scores_sample</span> <span class="o">=</span> <span class="n">score_paf_lines</span><span class="p">(</span>
            <span class="n">paf_lines_sample</span><span class="p">,</span> <span class="n">peaks_sample</span><span class="p">,</span> <span class="n">edge_peak_inds_sample</span><span class="p">,</span> <span class="n">max_edge_length</span>
        <span class="p">)</span>
        <span class="n">n_candidates</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">edge_peak_inds_sample</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">edge_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">edge_inds_sample</span><span class="p">)</span>
        <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">edge_peak_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">edge_peak_inds_sample</span><span class="p">)</span>
        <span class="n">line_scores</span> <span class="o">=</span> <span class="n">line_scores</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">line_scores_sample</span><span class="p">)</span>
        <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">sample_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">sample</span><span class="p">],</span> <span class="p">[</span><span class="n">n_candidates</span><span class="p">]))</span>

    <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">edge_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">edge_peak_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">line_scores</span> <span class="o">=</span> <span class="n">line_scores</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">sample_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>

    <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">edge_inds</span><span class="p">,</span> <span class="n">sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">edge_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">edge_peak_inds</span><span class="p">,</span> <span class="n">sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">line_scores</span><span class="p">,</span> <span class="n">sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">edge_inds</span><span class="p">,</span>
        <span class="n">edge_peak_inds</span><span class="p">,</span>
        <span class="n">line_scores</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tf_linear_sum_assignment"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.tf_linear_sum_assignment">[docs]</a><span class="nd">@tf</span><span class="o">.</span><span class="n">function</span>
<span class="k">def</span> <span class="nf">tf_linear_sum_assignment</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Run `linear_sum_assignment` as a TensorFlow function.</span>

<span class="sd">    Args:</span>
<span class="sd">        cost_matrix: Cost matrix of shape `(n_src, n_dst)`. Make sure to replace `NaN`s</span>
<span class="sd">            with `np.inf`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of `(row, col)` with the indices of the optimal assignments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_linear_sum_assignment</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap `linear_sum_assignment` for type safety.&quot;&quot;&quot;</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">numpy_function</span><span class="p">(</span>
        <span class="n">func</span><span class="o">=</span><span class="n">_linear_sum_assignment</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="p">[</span><span class="n">cost_matrix</span><span class="p">],</span> <span class="n">Tout</span><span class="o">=</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="match_candidates_sample"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.match_candidates_sample">[docs]</a><span class="k">def</span> <span class="nf">match_candidates_sample</span><span class="p">(</span>
    <span class="n">edge_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">edge_peak_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">line_scores_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_edges</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Match candidate connections for a sample based on PAF scores.</span>

<span class="sd">    Args:</span>
<span class="sd">        edge_inds_sample: A `tf.Tensor` of shape `(n_candidates,)` and dtype `tf.int32`</span>
<span class="sd">            indicating the indices of the edge that each of the candidate connections</span>
<span class="sd">            belongs to for the sample. Can be generated using</span>
<span class="sd">            `get_connection_candidates()`.</span>
<span class="sd">        edge_peak_inds_sample: A `tf.Tensor` of shape `(n_candidates, 2)` and dtype</span>
<span class="sd">            `tf.int32` with the indices of the peaks that form the source and</span>
<span class="sd">            destination of each candidate connection. Can be generated using</span>
<span class="sd">            `get_connection_candidates()`.</span>
<span class="sd">        line_scores_sample: Scores for each candidate connection in the sample as a</span>
<span class="sd">            `tf.Tensor` of shape `(n_candidates,)` and dtype `tf.float32`. Can be</span>
<span class="sd">            generated using `score_paf_lines()`.</span>
<span class="sd">        n_edges: A scalar `int` denoting the number of edges in the skeleton.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The connection peaks for each edge matched based on score as 4-tuple of:</span>

<span class="sd">        `match_edge_inds`: Indices of the skeleton edge that each connection corresponds</span>
<span class="sd">        to as a `tf.Tensor` of shape `(n_connections,)` and dtype `tf.int32`.</span>

<span class="sd">        `match_src_peak_inds`: Indices of the source peaks that form each connection</span>
<span class="sd">        as a `tf.Tensor` of shape `(n_connections,)` and dtype `tf.int32`. Important:</span>
<span class="sd">        These indices correspond to the edge-grouped peaks, not the set of all peaks in</span>
<span class="sd">        the sample.</span>

<span class="sd">        `match_dst_peak_inds`: Indices of the destination peaks that form each</span>
<span class="sd">        connection as a `tf.Tensor` of shape `(n_connections,)` and dtype `tf.int32`.</span>
<span class="sd">        Important: These indices correspond to the edge-grouped peaks, not the set of</span>
<span class="sd">        all peaks in the sample.</span>

<span class="sd">        `match_line_scores`: PAF line scores of the matched connections as a `tf.Tensor`</span>
<span class="sd">        of shape `(n_connections,)` and dtype `tf.float32`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The matching is performed using the Munkres algorithm implemented in</span>
<span class="sd">        `scipy.optimize.linear_sum_assignment()` which is wrapped in</span>
<span class="sd">        `tf_linear_sum_assignment()` for execution within a graph.</span>

<span class="sd">    See also: match_candidates_batch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_edges</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_edges</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_edges</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_edges</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edges</span><span class="p">):</span>

        <span class="n">is_edge_k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edge_inds_sample</span> <span class="o">==</span> <span class="n">k</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">edge_peak_inds_k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">edge_peak_inds_sample</span><span class="p">,</span> <span class="n">is_edge_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">line_scores_k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">line_scores_sample</span><span class="p">,</span> <span class="n">is_edge_k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get the unique peak indices</span>
        <span class="n">src_peak_inds_k</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edge_peak_inds_k</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">dst_peak_inds_k</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edge_peak_inds_k</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">n_src</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">src_peak_inds_k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_dst</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dst_peak_inds_k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Reshape line scores into cost matrix (n_src, n_dst)</span>
        <span class="n">scores_matrix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">line_scores_k</span><span class="p">,</span> <span class="p">[</span><span class="n">n_src</span><span class="p">,</span> <span class="n">n_dst</span><span class="p">])</span>

        <span class="c1"># Replace NaNs with inf since linear_sum_assignment doesn&#39;t accept NaNs and flip sign</span>
        <span class="n">cost_matrix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">is_nan</span><span class="p">(</span><span class="n">scores_matrix</span><span class="p">),</span>
            <span class="n">x</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]),</span>
            <span class="n">y</span><span class="o">=-</span><span class="n">scores_matrix</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Match</span>
        <span class="n">match_src_inds</span><span class="p">,</span> <span class="n">match_dst_inds</span> <span class="o">=</span> <span class="n">tf_linear_sum_assignment</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">)</span>

        <span class="c1"># Pull out matched scores.</span>
        <span class="n">match_subs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">match_src_inds</span><span class="p">,</span> <span class="n">match_dst_inds</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">match_line_scores_k</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">scores_matrix</span><span class="p">,</span> <span class="n">match_subs</span><span class="p">)</span>

        <span class="c1"># Get the peak indices for the matched points (these index into peaks_sample)</span>
        <span class="c1"># match_src_peak_inds_k = tf.gather(src_peak_inds_k, match_src_inds)</span>
        <span class="c1"># match_dst_peak_inds_k = tf.gather(dst_peak_inds_k, match_dst_inds)</span>
        <span class="c1"># These index into the edge-grouped peaks</span>
        <span class="n">match_src_peak_inds_k</span> <span class="o">=</span> <span class="n">match_src_inds</span>
        <span class="n">match_dst_peak_inds_k</span> <span class="o">=</span> <span class="n">match_dst_inds</span>

        <span class="c1"># Save</span>
        <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">match_edge_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">k</span><span class="p">],</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">match_src_peak_inds_k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span>
        <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">match_src_peak_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">match_src_peak_inds_k</span><span class="p">)</span>
        <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">match_dst_peak_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">match_dst_peak_inds_k</span><span class="p">)</span>
        <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">match_line_scores</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">match_line_scores_k</span><span class="p">)</span>

    <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">match_edge_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">match_src_peak_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">match_dst_peak_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">match_line_scores</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">match_edge_inds</span><span class="p">,</span>
        <span class="n">match_src_peak_inds</span><span class="p">,</span>
        <span class="n">match_dst_peak_inds</span><span class="p">,</span>
        <span class="n">match_line_scores</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="match_candidates_batch"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.match_candidates_batch">[docs]</a><span class="k">def</span> <span class="nf">match_candidates_batch</span><span class="p">(</span>
    <span class="n">edge_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">edge_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">line_scores</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">n_edges</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Match candidate connections for a batch based on PAF scores.</span>

<span class="sd">    Args:</span>
<span class="sd">        edge_inds: Sample-grouped edge indices as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_candidates))` and dtype `tf.int32` indicating the indices</span>
<span class="sd">            of the edge that each of the candidate connections belongs to. Can be</span>
<span class="sd">            generated using `score_paf_lines_batch()`.</span>
<span class="sd">        edge_peak_inds: Sample-grouped indices of the peaks that form the source and</span>
<span class="sd">            destination of each candidate connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_candidates), 2)` and dtype `tf.int32`. Can be generated</span>
<span class="sd">            using `score_paf_lines_batch()`.</span>
<span class="sd">        line_scores: Sample-grouped scores for each candidate connection as a</span>
<span class="sd">            `tf.RaggedTensor` of shape `(n_samples, (n_candidates))` and dtype</span>
<span class="sd">            `tf.float32`. Can be generated using `score_paf_lines_batch()`.</span>
<span class="sd">        n_edges: A scalar `int` denoting the number of edges in the skeleton.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The connection peaks for each edge matched based on score as 4-tuple of:</span>

<span class="sd">        `match_edge_inds`: Sample-grouped indices of the skeleton edge for each</span>
<span class="sd">        connection as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))` and</span>
<span class="sd">        dtype `tf.int32`.</span>

<span class="sd">        `match_src_peak_inds`: Sample-grouped indices of the source peaks that form each</span>
<span class="sd">        connection as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))` and</span>
<span class="sd">        dtype `tf.int32`. Important: These indices correspond to the edge-grouped peaks,</span>
<span class="sd">        not the set of all peaks in the sample.</span>

<span class="sd">        `match_dst_peak_inds`: Sample-grouped indices of the destination peaks that form</span>
<span class="sd">        each connection as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))`</span>
<span class="sd">        and dtype `tf.int32`. Important: These indices correspond to the edge-grouped</span>
<span class="sd">        peaks, not the set of all peaks in the sample.</span>

<span class="sd">        `match_line_scores`: Sample-grouped PAF line scores of the matched connections</span>
<span class="sd">        as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))` and dtype</span>
<span class="sd">        `tf.float32`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The matching is performed using the Munkres algorithm implemented in</span>
<span class="sd">        `scipy.optimize.linear_sum_assignment()` which is wrapped in</span>
<span class="sd">        `tf_linear_sum_assignment()` for execution within a graph.</span>

<span class="sd">    See also: match_candidates_sample, score_paf_lines_batch, group_instances_batch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">edge_inds</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span>

    <span class="n">match_sample_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
        <span class="n">edge_inds_sample</span> <span class="o">=</span> <span class="n">edge_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
        <span class="n">edge_peak_inds_sample</span> <span class="o">=</span> <span class="n">edge_peak_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
        <span class="n">line_scores_sample</span> <span class="o">=</span> <span class="n">line_scores</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>

        <span class="p">(</span>
            <span class="n">match_edge_inds_sample</span><span class="p">,</span>
            <span class="n">match_src_peak_inds_sample</span><span class="p">,</span>
            <span class="n">match_dst_peak_inds_sample</span><span class="p">,</span>
            <span class="n">match_line_scores_sample</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">match_candidates_sample</span><span class="p">(</span>
            <span class="n">edge_inds_sample</span><span class="p">,</span> <span class="n">edge_peak_inds_sample</span><span class="p">,</span> <span class="n">line_scores_sample</span><span class="p">,</span> <span class="n">n_edges</span>
        <span class="p">)</span>

        <span class="c1"># Save</span>
        <span class="n">match_sample_inds</span> <span class="o">=</span> <span class="n">match_sample_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">sample</span><span class="p">],</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">match_edge_inds_sample</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span>
        <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">match_edge_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">match_edge_inds_sample</span><span class="p">)</span>
        <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">match_src_peak_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">match_src_peak_inds_sample</span>
        <span class="p">)</span>
        <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">match_dst_peak_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">match_dst_peak_inds_sample</span>
        <span class="p">)</span>
        <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">match_line_scores</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">match_line_scores_sample</span><span class="p">)</span>

    <span class="n">match_sample_inds</span> <span class="o">=</span> <span class="n">match_sample_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">match_edge_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">match_src_peak_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">match_dst_peak_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">match_line_scores</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>

    <span class="n">match_edge_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">match_edge_inds</span><span class="p">,</span> <span class="n">match_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">match_src_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">match_src_peak_inds</span><span class="p">,</span> <span class="n">match_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">match_dst_peak_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">match_dst_peak_inds</span><span class="p">,</span> <span class="n">match_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">match_line_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">match_line_scores</span><span class="p">,</span> <span class="n">match_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">match_edge_inds</span><span class="p">,</span>
        <span class="n">match_src_peak_inds</span><span class="p">,</span>
        <span class="n">match_dst_peak_inds</span><span class="p">,</span>
        <span class="n">match_line_scores</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="assign_connections_to_instances"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.assign_connections_to_instances">[docs]</a><span class="k">def</span> <span class="nf">assign_connections_to_instances</span><span class="p">(</span>
    <span class="n">connections</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeConnection</span><span class="p">]],</span>
    <span class="n">min_instance_peaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">n_nodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">PeakID</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Assigns connected edges to instances via greedy graph partitioning.</span>

<span class="sd">    Args:</span>
<span class="sd">        connections: A dict that maps EdgeType to a list of EdgeConnections found</span>
<span class="sd">            through connection scoring. This can be generated by the</span>
<span class="sd">            filter_connection_candidates function.</span>
<span class="sd">        min_instance_peaks: If this is greater than 0, grouped instances with fewer</span>
<span class="sd">            assigned peaks than this threshold will be excluded. If a float in the</span>
<span class="sd">            range (0., 1.] is provided, this is interpreted as a fraction of the total</span>
<span class="sd">            number of nodes in the skeleton. If an integer is provided, this is the</span>
<span class="sd">            absolute minimum number of peaks.</span>
<span class="sd">        n_nodes: Total node type count. Used to convert min_instance_peaks to an</span>
<span class="sd">            absolute number when a fraction is specified. If not provided, the node</span>
<span class="sd">            count is inferred from the unique node inds in connections.</span>

<span class="sd">    Returns:</span>
<span class="sd">        instance_assignments: A dict mapping PeakID to a unique instance ID specified</span>
<span class="sd">        as an integer.</span>

<span class="sd">        A PeakID is a tuple of (node_type_ind, peak_ind), where the peak_ind is the</span>
<span class="sd">        index or identifier specified in a EdgeConnection as a src_peak_ind or</span>
<span class="sd">        dst_peak_ind.</span>

<span class="sd">    Note:</span>
<span class="sd">        Instance IDs are not necessarily consecutive since some instances may be</span>
<span class="sd">        filtered out during the partitioning or filtering.</span>

<span class="sd">        This function expects connections from a single sample/frame!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Grouping table that maps PeakID(node_ind, peak_ind) to an instance_id.</span>
    <span class="n">instance_assignments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Loop through edge types.</span>
    <span class="k">for</span> <span class="n">edge_type</span><span class="p">,</span> <span class="n">edge_connections</span> <span class="ow">in</span> <span class="n">connections</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="c1"># Loop through connections for the current edge.</span>
        <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">edge_connections</span><span class="p">:</span>

            <span class="c1"># Notation: specific peaks are identified by (node_ind, peak_ind).</span>
            <span class="n">src_id</span> <span class="o">=</span> <span class="n">PeakID</span><span class="p">(</span><span class="n">edge_type</span><span class="o">.</span><span class="n">src_node_ind</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">src_peak_ind</span><span class="p">)</span>
            <span class="n">dst_id</span> <span class="o">=</span> <span class="n">PeakID</span><span class="p">(</span><span class="n">edge_type</span><span class="o">.</span><span class="n">dst_node_ind</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">dst_peak_ind</span><span class="p">)</span>

            <span class="c1"># Get instance assignments for the connection peaks.</span>
            <span class="n">src_instance</span> <span class="o">=</span> <span class="n">instance_assignments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">src_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">dst_instance</span> <span class="o">=</span> <span class="n">instance_assignments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dst_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">src_instance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dst_instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Case 1: Neither peak is assigned to an instance yet. We&#39;ll create a</span>
                <span class="c1"># new instance to hold both.</span>
                <span class="n">new_instance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">instance_assignments</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">instance_assignments</span><span class="p">[</span><span class="n">src_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_instance</span>
                <span class="n">instance_assignments</span><span class="p">[</span><span class="n">dst_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_instance</span>

            <span class="k">elif</span> <span class="n">src_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dst_instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Case 2: The source peak is assigned already, but not the destination</span>
                <span class="c1"># peak. We&#39;ll assign the destination peak to the same instance as the</span>
                <span class="c1"># source.</span>
                <span class="n">instance_assignments</span><span class="p">[</span><span class="n">dst_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_instance</span>

            <span class="k">elif</span> <span class="n">src_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dst_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Case 3: Both peaks have been assigned. We&#39;ll update the destination</span>
                <span class="c1"># peak to be a part of the source peak instance.</span>
                <span class="n">instance_assignments</span><span class="p">[</span><span class="n">dst_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_instance</span>

                <span class="c1"># We&#39;ll also check if they form disconnected subgraphs, in which case</span>
                <span class="c1"># we&#39;ll merge them by assigning all peaks belonging to the destination</span>
                <span class="c1"># peak&#39;s instance to the source peak&#39;s instance.</span>
                <span class="n">src_instance_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">peak_id</span><span class="o">.</span><span class="n">node_ind</span>
                    <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instance_assignments</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">instance</span> <span class="o">==</span> <span class="n">src_instance</span>
                <span class="p">)</span>
                <span class="n">dst_instance_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">peak_id</span><span class="o">.</span><span class="n">node_ind</span>
                    <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instance_assignments</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">instance</span> <span class="o">==</span> <span class="n">dst_instance</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_instance_nodes</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">dst_instance_nodes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak_id</span> <span class="ow">in</span> <span class="n">instance_assignments</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">instance_assignments</span><span class="p">[</span><span class="n">peak_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">dst_instance</span><span class="p">:</span>
                            <span class="n">instance_assignments</span><span class="p">[</span><span class="n">peak_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_instance</span>

    <span class="k">if</span> <span class="n">min_instance_peaks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_instance_peaks</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">n_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Infer number of nodes if not specified.</span>
                <span class="n">all_node_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
                    <span class="n">all_node_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_type</span><span class="o">.</span><span class="n">src_node_ind</span><span class="p">)</span>
                    <span class="n">all_node_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_type</span><span class="o">.</span><span class="n">dst_node_ind</span><span class="p">)</span>
                <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_node_types</span><span class="p">)</span>

            <span class="c1"># Calculate minimum threshold.</span>
            <span class="n">min_instance_peaks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_instance_peaks</span> <span class="o">*</span> <span class="n">n_nodes</span><span class="p">)</span>

        <span class="c1"># Compute instance peak counts.</span>
        <span class="n">instance_ids</span><span class="p">,</span> <span class="n">instance_peak_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">instance_assignments</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">instance_peak_counts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">instance</span><span class="p">:</span> <span class="n">peaks_count</span>
            <span class="k">for</span> <span class="n">instance</span><span class="p">,</span> <span class="n">peaks_count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">instance_ids</span><span class="p">,</span> <span class="n">instance_peak_counts</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># Filter out small instances.</span>
        <span class="n">instance_assignments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">peak_id</span><span class="p">:</span> <span class="n">instance</span>
            <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instance_assignments</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">instance_peak_counts</span><span class="p">[</span><span class="n">instance</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_instance_peaks</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">instance_assignments</span></div>


<div class="viewcode-block" id="make_predicted_instances"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.make_predicted_instances">[docs]</a><span class="k">def</span> <span class="nf">make_predicted_instances</span><span class="p">(</span>
    <span class="n">peaks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">peak_scores</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">connections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeConnection</span><span class="p">],</span>
    <span class="n">instance_assignments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">PeakID</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Group peaks by assignments and accumulate scores.</span>

<span class="sd">    Args:</span>
<span class="sd">        peaks: Node-grouped peaks</span>
<span class="sd">        peak_scores: Node-grouped peak scores</span>
<span class="sd">        connections: `EdgeConnection`s grouped by edge type</span>
<span class="sd">        instance_assignments: `PeakID` to instance ID mapping</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (predicted_instances, predicted_peak_scores, predicted_instance_scores)</span>

<span class="sd">        predicted_instances: (n_instances, n_nodes, 2) array</span>
<span class="sd">        predicted_peak_scores: (n_instances, n_nodes) array</span>
<span class="sd">        predicted_instance_scores: (n_instances,) array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure instance IDs are contiguous.</span>
    <span class="n">instance_ids</span><span class="p">,</span> <span class="n">instance_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">instance_assignments</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">instance_ind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">instance_assignments</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">instance_inds</span><span class="p">):</span>
        <span class="n">instance_assignments</span><span class="p">[</span><span class="n">peak_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance_ind</span>
    <span class="n">n_instances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instance_ids</span><span class="p">)</span>

    <span class="c1"># Compute instance scores as the sum of all edge scores.</span>
    <span class="n">predicted_instance_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_instances</span><span class="p">,),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">edge_type</span><span class="p">,</span> <span class="n">edge_connections</span> <span class="ow">in</span> <span class="n">connections</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Loop over all connections for this edge type.</span>
        <span class="k">for</span> <span class="n">edge_connection</span> <span class="ow">in</span> <span class="n">edge_connections</span><span class="p">:</span>
            <span class="c1"># Look up the source peak.</span>
            <span class="n">src_peak_id</span> <span class="o">=</span> <span class="n">PeakID</span><span class="p">(</span>
                <span class="n">node_ind</span><span class="o">=</span><span class="n">edge_type</span><span class="o">.</span><span class="n">src_node_ind</span><span class="p">,</span> <span class="n">peak_ind</span><span class="o">=</span><span class="n">edge_connection</span><span class="o">.</span><span class="n">src_peak_ind</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">src_peak_id</span> <span class="ow">in</span> <span class="n">instance_assignments</span><span class="p">:</span>
                <span class="c1"># Add to the total instance score.</span>
                <span class="n">instance_ind</span> <span class="o">=</span> <span class="n">instance_assignments</span><span class="p">[</span><span class="n">src_peak_id</span><span class="p">]</span>
                <span class="n">predicted_instance_scores</span><span class="p">[</span><span class="n">instance_ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">edge_connection</span><span class="o">.</span><span class="n">score</span>

                <span class="c1"># Sanity check: both peaks in the edge should have been assigned to the</span>
                <span class="c1"># same instance.</span>
                <span class="n">dst_peak_id</span> <span class="o">=</span> <span class="n">PeakID</span><span class="p">(</span>
                    <span class="n">node_ind</span><span class="o">=</span><span class="n">edge_type</span><span class="o">.</span><span class="n">dst_node_ind</span><span class="p">,</span>
                    <span class="n">peak_ind</span><span class="o">=</span><span class="n">edge_connection</span><span class="o">.</span><span class="n">dst_peak_ind</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="n">instance_ind</span> <span class="o">==</span> <span class="n">instance_assignments</span><span class="p">[</span><span class="n">dst_peak_id</span><span class="p">]</span>

    <span class="c1"># Fill out instances and peak scores.</span>
    <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_instances</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">predicted_peak_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_instances</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">peak_id</span><span class="p">,</span> <span class="n">instance_ind</span> <span class="ow">in</span> <span class="n">instance_assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">predicted_instances</span><span class="p">[</span><span class="n">instance_ind</span><span class="p">,</span> <span class="n">peak_id</span><span class="o">.</span><span class="n">node_ind</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span>
            <span class="n">peak_id</span><span class="o">.</span><span class="n">node_ind</span>
        <span class="p">][</span><span class="n">peak_id</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">]</span>
        <span class="n">predicted_peak_scores</span><span class="p">[</span><span class="n">instance_ind</span><span class="p">,</span> <span class="n">peak_id</span><span class="o">.</span><span class="n">node_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">peak_scores</span><span class="p">[</span>
            <span class="n">peak_id</span><span class="o">.</span><span class="n">node_ind</span>
        <span class="p">][</span><span class="n">peak_id</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">predicted_instances</span><span class="p">,</span> <span class="n">predicted_peak_scores</span><span class="p">,</span> <span class="n">predicted_instance_scores</span></div>


<div class="viewcode-block" id="group_instances_sample"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.group_instances_sample">[docs]</a><span class="k">def</span> <span class="nf">group_instances_sample</span><span class="p">(</span>
    <span class="n">peaks_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">peak_scores_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">peak_channel_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">match_edge_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">match_src_peak_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">match_dst_peak_inds_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">match_line_scores_sample</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_nodes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_edges</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">edge_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">],</span>
    <span class="n">min_instance_peaks</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Group matched connections into full instances for a single sample.</span>

<span class="sd">    Args:</span>
<span class="sd">        peaks_sample: The detected peaks in a sample as a `tf.Tensor` of shape</span>
<span class="sd">            `(n_peaks, 2)` and dtype `tf.float32`. These should be `(x, y)` coordinates</span>
<span class="sd">            of each peak in the image scale.</span>
<span class="sd">        peak_scores_sample: The scores of the detected peaks in a sample as a</span>
<span class="sd">            `tf.Tensor` of shape `(n_peaks,)` and dtype `tf.float32`.</span>
<span class="sd">        peak_channel_inds_sample: The indices of the channel (node) that each detected</span>
<span class="sd">            peak is associated with as a `tf.Tensor` of shape `(n_peaks,)` and dtype</span>
<span class="sd">            `tf.int32`.</span>
<span class="sd">        match_edge_inds_sample: Indices of the skeleton edge that each connection</span>
<span class="sd">            corresponds to as a `tf.Tensor` of shape `(n_connections,)` and dtype</span>
<span class="sd">            `tf.int32`. This can be generated by `match_candidates_sample()`.</span>
<span class="sd">        match_src_peak_inds_sample: Indices of the source peaks that form each</span>
<span class="sd">            connection as a `tf.Tensor` of shape `(n_connections,)` and dtype</span>
<span class="sd">            `tf.int32`. Important: These indices correspond to the edge-grouped peaks,</span>
<span class="sd">            not the set of all peaks in the sample. This can be generated by</span>
<span class="sd">            `match_candidates_sample()`.</span>
<span class="sd">        match_dst_peak_inds_sample: Indices of the destination peaks that form each</span>
<span class="sd">            connection as a `tf.Tensor` of shape `(n_connections,)` and dtype</span>
<span class="sd">            `tf.int32`. Important: These indices correspond to the edge-grouped peaks,</span>
<span class="sd">            not the set of all peaks in the sample. This can be generated by</span>
<span class="sd">            `match_candidates_sample()`.</span>
<span class="sd">        match_line_scores_sample: PAF line scores of the matched connections as a</span>
<span class="sd">            `tf.Tensor` of shape `(n_connections,)` and dtype `tf.float32`. This can be</span>
<span class="sd">            generated by `match_candidates_sample()`.</span>
<span class="sd">        n_nodes: The total number of nodes in the skeleton as a scalar integer.</span>
<span class="sd">        n_edges: A scalar `int` denoting the number of edges in the skeleton.</span>
<span class="sd">        edge_types: A list of `EdgeType`s associated with the skeleton.</span>
<span class="sd">        min_instance_peaks: If this is greater than 0, grouped instances with fewer</span>
<span class="sd">            assigned peaks than this threshold will be excluded. If a `float` in the</span>
<span class="sd">            range `(0., 1.]` is provided, this is interpreted as a fraction of the total</span>
<span class="sd">            number of nodes in the skeleton. If an `int` is provided, this is the</span>
<span class="sd">            absolute minimum number of peaks.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of arrays with the grouped instances:</span>

<span class="sd">        `predicted_instances`: The grouped coordinates for each instance as an array of</span>
<span class="sd">        shape `(n_instances, n_nodes, 2)` and dtype `float32`. Missing peaks are</span>
<span class="sd">        represented by `np.NaN`s.</span>

<span class="sd">        `predicted_peak_scores`: The confidence map values for each peak as an array of</span>
<span class="sd">        `(n_instances, n_nodes)` and dtype `float32`.</span>

<span class="sd">        `predicted_instance_scores`: The grouping score for each instance as an array of</span>
<span class="sd">        shape `(n_instances,)` and dtype `float32`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function is meant to be run as a `tf.py_function` within a graph (see</span>
<span class="sd">        `group_instances_batch()`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peaks_sample</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="c1"># Convert all the data to numpy arrays.</span>
        <span class="n">peaks_sample</span> <span class="o">=</span> <span class="n">peaks_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">peak_scores_sample</span> <span class="o">=</span> <span class="n">peak_scores_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">peak_channel_inds_sample</span> <span class="o">=</span> <span class="n">peak_channel_inds_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">match_edge_inds_sample</span> <span class="o">=</span> <span class="n">match_edge_inds_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">match_src_peak_inds_sample</span> <span class="o">=</span> <span class="n">match_src_peak_inds_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">match_dst_peak_inds_sample</span> <span class="o">=</span> <span class="n">match_dst_peak_inds_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">match_line_scores_sample</span> <span class="o">=</span> <span class="n">match_line_scores_sample</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># Group peaks by channel.</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">peak_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">):</span>
        <span class="n">in_channel</span> <span class="o">=</span> <span class="n">peak_channel_inds_sample</span> <span class="o">==</span> <span class="n">i</span>
        <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peaks_sample</span><span class="p">[</span><span class="n">in_channel</span><span class="p">])</span>
        <span class="n">peak_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak_scores_sample</span><span class="p">[</span><span class="n">in_channel</span><span class="p">])</span>

    <span class="c1"># Group connection data by edge.</span>
    <span class="n">src_peak_inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dst_peak_inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">line_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edges</span><span class="p">):</span>
        <span class="n">in_edge</span> <span class="o">=</span> <span class="n">match_edge_inds_sample</span> <span class="o">==</span> <span class="n">i</span>
        <span class="n">src_peak_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_src_peak_inds_sample</span><span class="p">[</span><span class="n">in_edge</span><span class="p">])</span>
        <span class="n">dst_peak_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_dst_peak_inds_sample</span><span class="p">[</span><span class="n">in_edge</span><span class="p">])</span>
        <span class="n">line_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_line_scores_sample</span><span class="p">[</span><span class="n">in_edge</span><span class="p">])</span>

    <span class="c1"># Form connections structure.</span>
    <span class="n">connections</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">src_peak_ind</span><span class="p">,</span> <span class="n">dst_peak_ind</span><span class="p">,</span> <span class="n">line_score</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">src_peak_inds</span><span class="p">,</span> <span class="n">dst_peak_inds</span><span class="p">,</span> <span class="n">line_scores</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">connections</span><span class="p">[</span><span class="n">edge_types</span><span class="p">[</span><span class="n">edge_ind</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">EdgeConnection</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_peak_ind</span><span class="p">,</span> <span class="n">dst_peak_ind</span><span class="p">,</span> <span class="n">line_score</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="c1"># Bipartite graph partitioning to group connections into instances.</span>
    <span class="n">instance_assignments</span> <span class="o">=</span> <span class="n">assign_connections_to_instances</span><span class="p">(</span>
        <span class="n">connections</span><span class="p">,</span>
        <span class="n">min_instance_peaks</span><span class="o">=</span><span class="n">min_instance_peaks</span><span class="p">,</span>
        <span class="n">n_nodes</span><span class="o">=</span><span class="n">n_nodes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Gather the data by instance.</span>
    <span class="p">(</span>
        <span class="n">predicted_instances</span><span class="p">,</span>
        <span class="n">predicted_peak_scores</span><span class="p">,</span>
        <span class="n">predicted_instance_scores</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">make_predicted_instances</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">peak_scores</span><span class="p">,</span> <span class="n">connections</span><span class="p">,</span> <span class="n">instance_assignments</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">predicted_instances</span><span class="p">,</span> <span class="n">predicted_peak_scores</span><span class="p">,</span> <span class="n">predicted_instance_scores</span></div>


<div class="viewcode-block" id="group_instances_batch"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.group_instances_batch">[docs]</a><span class="k">def</span> <span class="nf">group_instances_batch</span><span class="p">(</span>
    <span class="n">peaks</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">peak_vals</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">peak_channel_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">match_edge_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">match_src_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">match_dst_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">match_line_scores</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="n">n_nodes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_edges</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">edge_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">],</span>
    <span class="n">min_instance_peaks</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Group matched connections into full instances for a batch.</span>

<span class="sd">    Args:</span>
<span class="sd">        peaks: The sample-grouped detected peaks in a batch as a `tf.RaggedTensor` of</span>
<span class="sd">            shape `(n_samples, (n_peaks), 2)` and dtype `tf.float32`. These should be</span>
<span class="sd">            `(x, y)` coordinates of each peak in the image scale.</span>
<span class="sd">        peak_vals: The sample-grouped scores of the detected peaks in a batch as a</span>
<span class="sd">            `tf.RaggedTensor` of shape `(n_samples, (n_peaks))` and dtype `tf.float32`.</span>
<span class="sd">        peak_channel_inds: The sample-grouped indices of the channel (node) that each</span>
<span class="sd">            detected peak is associated with as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_peaks))` and dtype `tf.int32`.</span>
<span class="sd">        match_edge_inds: Sample-grouped indices of the skeleton edge that each</span>
<span class="sd">            connection corresponds to as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_connections))` and dtype `tf.int32`. This can be generated</span>
<span class="sd">            by `match_candidates_batch()`.</span>
<span class="sd">        match_src_peak_inds: Sample-grouped indices of the source peaks that form each</span>
<span class="sd">            connection as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))`</span>
<span class="sd">            and dtype `tf.int32`. Important: These indices correspond to the</span>
<span class="sd">            edge-grouped peaks, not the set of all peaks in each sample. This can be</span>
<span class="sd">            generated by `match_candidates_batch()`.</span>
<span class="sd">        match_dst_peak_inds: Sample-grouped indices of the destination peaks that form</span>
<span class="sd">            each connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_connections))` and dtype `tf.int32`. Important: These</span>
<span class="sd">            indices correspond to the edge-grouped peaks, not the set of all peaks in</span>
<span class="sd">            the sample. This can be generated by `match_candidates_batch()`.</span>
<span class="sd">        match_line_scores: Sample-grouped PAF line scores of the matched connections as</span>
<span class="sd">            a `tf.RaggedTensor` of shape `(n_samples, (n_connections))` and dtype</span>
<span class="sd">            `tf.float32`. This can be generated by `match_candidates_batch()`.</span>
<span class="sd">        n_nodes: The total number of nodes in the skeleton as a scalar integer.</span>
<span class="sd">        n_edges: A scalar `int` denoting the number of edges in the skeleton.</span>
<span class="sd">        edge_types: A list of `EdgeType`s associated with the skeleton.</span>
<span class="sd">        min_instance_peaks: If this is greater than 0, grouped instances with fewer</span>
<span class="sd">            assigned peaks than this threshold will be excluded. If a `float` in the</span>
<span class="sd">            range `(0., 1.]` is provided, this is interpreted as a fraction of the total</span>
<span class="sd">            number of nodes in the skeleton. If an `int` is provided, this is the</span>
<span class="sd">            absolute minimum number of peaks.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of arrays with the grouped instances for the whole batch grouped by</span>
<span class="sd">        sample:</span>

<span class="sd">        `predicted_instances`: The sample- and instance-grouped coordinates for each</span>
<span class="sd">        instance as `tf.RaggedTensor` of shape `(n_samples, (n_instances), n_nodes, 2)`</span>
<span class="sd">        and dtype `tf.float32`. Missing peaks are represented by `NaN`s.</span>

<span class="sd">        `predicted_peak_scores`: The sample- and instance-grouped confidence map values</span>
<span class="sd">        for each peak as an array of `(n_samples, (n_instances), n_nodes)` and dtype</span>
<span class="sd">        `tf.float32`.</span>

<span class="sd">        `predicted_instance_scores`: The sample-grouped instance grouping score for each</span>
<span class="sd">        instance as an array of shape `(n_samples, (n_instances))` and dtype</span>
<span class="sd">        `tf.float32`.</span>

<span class="sd">    See also: match_candidates_batch, group_instances_sample</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_group_instances_sample</span><span class="p">(</span>
        <span class="n">peaks_sample</span><span class="p">,</span>
        <span class="n">peak_scores_sample</span><span class="p">,</span>
        <span class="n">peak_channel_inds_sample</span><span class="p">,</span>
        <span class="n">match_edge_inds_sample</span><span class="p">,</span>
        <span class="n">match_src_peak_inds_sample</span><span class="p">,</span>
        <span class="n">match_dst_peak_inds_sample</span><span class="p">,</span>
        <span class="n">match_line_scores_sample</span><span class="p">,</span>
        <span class="n">n_nodes</span><span class="p">,</span>
        <span class="n">n_edges</span><span class="p">,</span>
        <span class="n">min_instance_peaks</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper to avoid passing `EdgeType`s to `tf.py_function`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group_instances_sample</span><span class="p">(</span>
            <span class="n">peaks_sample</span><span class="p">,</span>
            <span class="n">peak_scores_sample</span><span class="p">,</span>
            <span class="n">peak_channel_inds_sample</span><span class="p">,</span>
            <span class="n">match_edge_inds_sample</span><span class="p">,</span>
            <span class="n">match_src_peak_inds_sample</span><span class="p">,</span>
            <span class="n">match_dst_peak_inds_sample</span><span class="p">,</span>
            <span class="n">match_line_scores_sample</span><span class="p">,</span>
            <span class="n">n_nodes</span><span class="p">,</span>
            <span class="n">n_edges</span><span class="p">,</span>
            <span class="n">edge_types</span><span class="p">,</span>
            <span class="n">min_instance_peaks</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">peaks</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span>

    <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">predicted_peak_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">predicted_instance_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorArray</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">infer_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>

        <span class="c1"># Call sample-wise function in Eager mode.</span>
        <span class="p">(</span>
            <span class="n">predicted_instances_sample</span><span class="p">,</span>
            <span class="n">predicted_peak_scores_sample</span><span class="p">,</span>
            <span class="n">predicted_instance_scores_sample</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">py_function</span><span class="p">(</span>
            <span class="n">_group_instances_sample</span><span class="p">,</span>
            <span class="n">inp</span><span class="o">=</span><span class="p">[</span>
                <span class="n">peaks</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">peak_vals</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">peak_channel_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">match_edge_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">match_src_peak_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">match_dst_peak_inds</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">match_line_scores</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span>
                <span class="n">n_nodes</span><span class="p">,</span>
                <span class="n">n_edges</span><span class="p">,</span>
                <span class="c1"># edge_types, # not serializable!</span>
                <span class="n">min_instance_peaks</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">Tout</span><span class="o">=</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">sample_inds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">sample</span><span class="p">],</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">predicted_instances_sample</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span>
        <span class="n">predicted_instances</span> <span class="o">=</span> <span class="n">predicted_instances</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">predicted_instances_sample</span>
        <span class="p">)</span>
        <span class="n">predicted_peak_scores</span> <span class="o">=</span> <span class="n">predicted_peak_scores</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">predicted_peak_scores_sample</span>
        <span class="p">)</span>
        <span class="n">predicted_instance_scores</span> <span class="o">=</span> <span class="n">predicted_instance_scores</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">predicted_instance_scores_sample</span>
        <span class="p">)</span>

    <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">sample_inds</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="n">predicted_instances</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">predicted_peak_scores</span> <span class="o">=</span> <span class="n">predicted_peak_scores</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>
    <span class="n">predicted_instance_scores</span> <span class="o">=</span> <span class="n">predicted_instance_scores</span><span class="o">.</span><span class="n">concat</span><span class="p">()</span>

    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">predicted_instances</span><span class="p">,</span> <span class="n">sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">predicted_peak_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">predicted_peak_scores</span><span class="p">,</span> <span class="n">sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>
    <span class="n">predicted_instance_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
        <span class="n">predicted_instance_scores</span><span class="p">,</span> <span class="n">sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">n_samples</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">predicted_instances</span><span class="p">,</span> <span class="n">predicted_peak_scores</span><span class="p">,</span> <span class="n">predicted_instance_scores</span></div>


<div class="viewcode-block" id="PAFScorer"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PAFScorer">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">PAFScorer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Scoring pipeline based on part affinity fields.</span>

<span class="sd">    This class facilitates grouping of predicted peaks based on PAFs. It holds a set of</span>
<span class="sd">    common parameters that are used across different steps of the pipeline.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        part_names: List of string node names in the skeleton.</span>
<span class="sd">        edges: List of (src_node, dst_node) names in the skeleton.</span>
<span class="sd">        pafs_stride: Output stride of the part affinity fields. This will be used to</span>
<span class="sd">            adjust the peak coordinates from full image to PAF subscripts.</span>
<span class="sd">        max_edge_length_ratio: The maximum expected length of a connected pair of points</span>
<span class="sd">            in relative image units. Candidate connections above this length will be</span>
<span class="sd">            penalized during matching.</span>
<span class="sd">        n_points: Number of points to sample along the line integral.</span>
<span class="sd">        min_instance_peaks: Minimum number of peaks the instance should have to be</span>
<span class="sd">            considered a real instance. Instances with fewer peaks than this will be</span>
<span class="sd">            discarded (useful for filtering spurious detections).</span>
<span class="sd">        edge_inds: The edges of the skeleton defined as a list of (source, destination)</span>
<span class="sd">            tuples of node indices. This is created automatically on initialization.</span>
<span class="sd">        edge_types: A list of `EdgeType` instances representing the edges of the</span>
<span class="sd">            skeleton. This is created automatically on initialization.</span>
<span class="sd">        n_nodes: The number of nodes in the skeleton as a scalar `int`. This is created</span>
<span class="sd">            automatically on initialization.</span>
<span class="sd">        n_edges: The number of edges in the skeleton as a scalar `int`. This is created</span>
<span class="sd">            automatically on initialization.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This class provides high level APIs for grouping peaks into instances using</span>
<span class="sd">        PAFs.</span>

<span class="sd">        The algorithm has three steps:</span>

<span class="sd">            1. Find all candidate connections between peaks and compute their matching</span>
<span class="sd">            score based on the PAFs.</span>

<span class="sd">            2. Match candidate connections using the connectivity score such that no</span>
<span class="sd">            peak is used in two connections of the same type.</span>

<span class="sd">            3. Group matched connections into complete instances.</span>

<span class="sd">        In general, the output from a peak finder (such as multi-peak confidence map</span>
<span class="sd">        prediction network) can be passed into `PAFScorer.predict()` to get back</span>
<span class="sd">        complete instances.</span>

<span class="sd">        For finer control over the grouping pipeline steps, use the instance methods in</span>
<span class="sd">        this class or the lower level functions in `sleap.nn.paf_grouping`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">part_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="n">Text</span><span class="p">]]</span>
    <span class="n">pafs_stride</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">max_edge_length_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">min_instance_peaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">edge_inds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">edge_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">n_nodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">n_edges</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache some computed attributes on initialization.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_inds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">part_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">part_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">EdgeType</span><span class="p">(</span><span class="n">src_node</span><span class="p">,</span> <span class="n">dst_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">src_node</span><span class="p">,</span> <span class="n">dst_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_inds</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">part_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>

<div class="viewcode-block" id="PAFScorer.from_config"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PAFScorer.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">MultiInstanceConfig</span><span class="p">,</span>
        <span class="n">max_edge_length_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">min_instance_peaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PAFScorer&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the PAF scorer from a `MultiInstanceConfig` head config.</span>

<span class="sd">        Args:</span>
<span class="sd">            config: `MultiInstanceConfig` from `cfg.model.heads.multi_instance`.</span>
<span class="sd">            max_edge_length_ratio: The maximum expected length of a connected pair of</span>
<span class="sd">                points relative image units. Candidate connections above this length</span>
<span class="sd">                will be penalized during matching.</span>
<span class="sd">            min_edge_score: Minimum score required to classify a connection as correct.</span>
<span class="sd">            n_points: Number of points to sample along the line integral.</span>
<span class="sd">            min_instance_peaks: Minimum number of peaks the instance should have to be</span>
<span class="sd">                considered a real instance. Instances with fewer peaks than this will be</span>
<span class="sd">                discarded (useful for filtering spurious detections).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The initialized instance of `PAFScorer`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">part_names</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">confmaps</span><span class="o">.</span><span class="n">part_names</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">pafs</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">pafs_stride</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">pafs</span><span class="o">.</span><span class="n">output_stride</span><span class="p">,</span>
            <span class="n">max_edge_length_ratio</span><span class="o">=</span><span class="n">max_edge_length_ratio</span><span class="p">,</span>
            <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span>
            <span class="n">min_instance_peaks</span><span class="o">=</span><span class="n">min_instance_peaks</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PAFScorer.score_paf_lines"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PAFScorer.score_paf_lines">[docs]</a>    <span class="k">def</span> <span class="nf">score_paf_lines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pafs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">peaks</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">peak_channel_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Create and score PAF lines formed between connection candidates.</span>

<span class="sd">        Args:</span>
<span class="sd">            pafs: The batch of part affinity fields as a `tf.Tensor` of shape</span>
<span class="sd">                `(n_samples, height, width, 2 * n_edges)` and type `tf.float32`.</span>
<span class="sd">            peaks: The coordinates of the peaks grouped by sample as a `tf.RaggedTensor`</span>
<span class="sd">                of shape `(n_samples, (n_peaks), 2)`.</span>
<span class="sd">            peak_channel_inds: The channel (node) that each peak in `peaks` corresponds</span>
<span class="sd">                to as a `tf.RaggedTensor` of shape `(n_samples, (n_peaks))` and dtype</span>
<span class="sd">                `tf.int32`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of `(edge_inds, edge_peak_inds, line_scores)` with the connections</span>
<span class="sd">            and their scores based on the PAFs.</span>

<span class="sd">            `edge_inds`: Sample-grouped indices of the edge in the skeleton that each</span>
<span class="sd">            connection corresponds to as `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_candidates))` and dtype `tf.int32`.</span>

<span class="sd">            `edge_peak_inds`: Sample-grouped indices of the peaks that form each</span>
<span class="sd">            connection as a `tf.RaggedTensor` of shape `(n_samples, (n_candidates), 2)`</span>
<span class="sd">            and dtype `tf.int32`. The last axis corresponds to the</span>
<span class="sd">            `[source, destination]` peak indices. These index into the input</span>
<span class="sd">            `peak_channel_inds`.</span>

<span class="sd">            `line_scores`: Sample-grouped scores for each candidate connection as a</span>
<span class="sd">            `tf.RaggedTensor` of shape `(n_samples, (n_candidates))` and dtype</span>
<span class="sd">            `tf.float32`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This is a convenience wrapper for the standalone `score_paf_lines_batch()`.</span>

<span class="sd">        See also: score_paf_lines_batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">score_paf_lines_batch</span><span class="p">(</span>
            <span class="n">pafs</span><span class="p">,</span>
            <span class="n">peaks</span><span class="p">,</span>
            <span class="n">peak_channel_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pafs_stride</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_edge_length_ratio</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PAFScorer.match_candidates"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PAFScorer.match_candidates">[docs]</a>    <span class="k">def</span> <span class="nf">match_candidates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">edge_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">line_scores</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Match candidate connections for a batch based on PAF scores.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_inds: Sample-grouped edge indices as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(n_samples, (n_candidates))` and dtype `tf.int32` indicating the</span>
<span class="sd">                indices of the edge that each of the candidate connections belongs to.</span>
<span class="sd">                Can be generated using `PAFScorer.score_paf_lines()`.</span>
<span class="sd">            edge_peak_inds: Sample-grouped indices of the peaks that form the source and</span>
<span class="sd">                destination of each candidate connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(n_samples, (n_candidates), 2)` and dtype `tf.int32`. Can be generated</span>
<span class="sd">                using `PAFScorer.score_paf_lines()`.</span>
<span class="sd">            line_scores: Sample-grouped scores for each candidate connection as a</span>
<span class="sd">                `tf.RaggedTensor` of shape `(n_samples, (n_candidates))` and dtype</span>
<span class="sd">                `tf.float32`. Can be generated using `PAFScorer.score_paf_lines()`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The connection peaks for each edge matched based on score as 4-tuple of:</span>

<span class="sd">            `match_edge_inds`: Sample-grouped indices of the skeleton edge for each</span>
<span class="sd">            connection as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))`</span>
<span class="sd">            and dtype `tf.int32`.</span>

<span class="sd">            `match_src_peak_inds`: Sample-grouped indices of the source peaks that form</span>
<span class="sd">            each connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_connections))` and dtype `tf.int32`. Important: These</span>
<span class="sd">            indices correspond to the edge-grouped peaks, not the set of all peaks in</span>
<span class="sd">            the sample.</span>

<span class="sd">            `match_dst_peak_inds`: Sample-grouped indices of the destination peaks that</span>
<span class="sd">            form each connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_connections))` and dtype `tf.int32`. Important: These</span>
<span class="sd">            indices correspond to the edge-grouped peaks, not the set of all peaks in</span>
<span class="sd">            the sample.</span>

<span class="sd">            `match_line_scores`: Sample-grouped PAF line scores of the matched</span>
<span class="sd">            connections as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))`</span>
<span class="sd">            and dtype `tf.float32`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This is a convenience wrapper for the standalone `match_candidates_batch()`.</span>

<span class="sd">        See also: PAFScorer.score_paf_lines, match_candidates_batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">match_candidates_batch</span><span class="p">(</span>
            <span class="n">edge_inds</span><span class="p">,</span> <span class="n">edge_peak_inds</span><span class="p">,</span> <span class="n">line_scores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PAFScorer.group_instances"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PAFScorer.group_instances">[docs]</a>    <span class="k">def</span> <span class="nf">group_instances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">peaks</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">peak_vals</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">peak_channel_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">match_edge_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">match_src_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">match_dst_peak_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">match_line_scores</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Group matched connections into full instances for a batch.</span>

<span class="sd">        Args:</span>
<span class="sd">            peaks: The sample-grouped detected peaks in a batch as a `tf.RaggedTensor`</span>
<span class="sd">                of shape `(n_samples, (n_peaks), 2)` and dtype `tf.float32`. These</span>
<span class="sd">                should be `(x, y)` coordinates of each peak in the image scale.</span>
<span class="sd">            peak_vals: The sample-grouped scores of the detected peaks in a batch as a</span>
<span class="sd">                `tf.RaggedTensor` of shape `(n_samples, (n_peaks))` and dtype</span>
<span class="sd">                `tf.float32`.</span>
<span class="sd">            peak_channel_inds: The sample-grouped indices of the channel (node) that</span>
<span class="sd">                each detected peak is associated with as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(n_samples, (n_peaks))` and dtype `tf.int32`.</span>
<span class="sd">            match_edge_inds: Sample-grouped indices of the skeleton edge that each</span>
<span class="sd">                connection corresponds to as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(n_samples, (n_connections))` and dtype `tf.int32`. This can be</span>
<span class="sd">                generated by `PAFScorer.match_candidates()`.</span>
<span class="sd">            match_src_peak_inds: Sample-grouped indices of the source peaks that form</span>
<span class="sd">                each connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(n_samples, (n_connections))` and dtype `tf.int32`. Important: These</span>
<span class="sd">                indices correspond to the edge-grouped peaks, not the set of all peaks</span>
<span class="sd">                in each sample. This can be generated by `PAFScorer.match_candidates()`.</span>
<span class="sd">            match_dst_peak_inds: Sample-grouped indices of the destination peaks that</span>
<span class="sd">                form each connection as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(n_samples, (n_connections))` and dtype `tf.int32`. Important: These</span>
<span class="sd">                indices correspond to the edge-grouped peaks, not the set of all peaks</span>
<span class="sd">                in the sample. This can be generated by `PAFScorer.match_candidates()`.</span>
<span class="sd">            match_line_scores: Sample-grouped PAF line scores of the matched connections</span>
<span class="sd">                as a `tf.RaggedTensor` of shape `(n_samples, (n_connections))` and dtype</span>
<span class="sd">                `tf.float32`. This can be generated by `PAFScorer.match_candidates()`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of arrays with the grouped instances for the whole batch grouped by</span>
<span class="sd">            sample:</span>

<span class="sd">            `predicted_instances`: The sample- and instance-grouped coordinates for each</span>
<span class="sd">            instance as `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_instances), n_nodes, 2)` and dtype `tf.float32`. Missing</span>
<span class="sd">            peaks are represented by `NaN`s.</span>

<span class="sd">            `predicted_peak_scores`: The sample- and instance-grouped confidence map</span>
<span class="sd">            values for each peak as an array of `(n_samples, (n_instances), n_nodes)`</span>
<span class="sd">            and dtype `tf.float32`.</span>

<span class="sd">            `predicted_instance_scores`: The sample-grouped instance grouping score for</span>
<span class="sd">            each instance as an array of shape `(n_samples, (n_instances))` and dtype</span>
<span class="sd">            `tf.float32`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This is a convenience wrapper for the standalone `group_instances_batch()`.</span>

<span class="sd">        See also: PAFScorer.match_candidates, group_instances_batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group_instances_batch</span><span class="p">(</span>
            <span class="n">peaks</span><span class="p">,</span>
            <span class="n">peak_vals</span><span class="p">,</span>
            <span class="n">peak_channel_inds</span><span class="p">,</span>
            <span class="n">match_edge_inds</span><span class="p">,</span>
            <span class="n">match_src_peak_inds</span><span class="p">,</span>
            <span class="n">match_dst_peak_inds</span><span class="p">,</span>
            <span class="n">match_line_scores</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_instance_peaks</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PAFScorer.predict"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.paf_grouping.html#sleap.nn.paf_grouping.PAFScorer.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pafs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">peaks</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">peak_vals</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
        <span class="n">peak_channel_inds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Group a batch of predicted peaks into full instance predictions using PAFs.</span>

<span class="sd">        Args:</span>
<span class="sd">            pafs: The batch of part affinity fields as a `tf.Tensor` of shape</span>
<span class="sd">                `(n_samples, height, width, 2 * n_edges)` and type `tf.float32`.</span>
<span class="sd">            peaks: The coordinates of the peaks grouped by sample as a `tf.RaggedTensor`</span>
<span class="sd">                of shape `(n_samples, (n_peaks), 2)`.</span>
<span class="sd">            peak_vals: The sample-grouped scores of the detected peaks in a batch as a</span>
<span class="sd">                `tf.RaggedTensor` of shape `(n_samples, (n_peaks))` and dtype</span>
<span class="sd">                `tf.float32`.</span>
<span class="sd">            peak_channel_inds: The channel (node) that each peak in `peaks` corresponds</span>
<span class="sd">                to as a `tf.RaggedTensor` of shape `(n_samples, (n_peaks))` and dtype</span>
<span class="sd">                `tf.int32`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of arrays with the grouped instances for the whole batch grouped by</span>
<span class="sd">            sample:</span>

<span class="sd">            `predicted_instances`: The sample- and instance-grouped coordinates for each</span>
<span class="sd">            instance as `tf.RaggedTensor` of shape</span>
<span class="sd">            `(n_samples, (n_instances), n_nodes, 2)` and dtype `tf.float32`. Missing</span>
<span class="sd">            peaks are represented by `NaN`s.</span>

<span class="sd">            `predicted_peak_scores`: The sample- and instance-grouped confidence map</span>
<span class="sd">            values for each peak as an array of `(n_samples, (n_instances), n_nodes)`</span>
<span class="sd">            and dtype `tf.float32`.</span>

<span class="sd">            `predicted_instance_scores`: The sample-grouped instance grouping score for</span>
<span class="sd">            each instance as an array of shape `(n_samples, (n_instances))` and dtype</span>
<span class="sd">            `tf.float32`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This is a high level API for grouping peaks into instances using PAFs. </span>

<span class="sd">            See the `PAFScorer` class documentation for more details on the algorithm.</span>

<span class="sd">        See also:</span>
<span class="sd">            PAFScorer.score_paf_lines, PAFScorer.match_candidates,</span>
<span class="sd">            PAFScorer.group_instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_inds</span><span class="p">,</span> <span class="n">edge_peak_inds</span><span class="p">,</span> <span class="n">line_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_paf_lines</span><span class="p">(</span>
            <span class="n">pafs</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">peak_channel_inds</span>
        <span class="p">)</span>
        <span class="p">(</span>
            <span class="n">match_edge_inds</span><span class="p">,</span>
            <span class="n">match_src_peak_inds</span><span class="p">,</span>
            <span class="n">match_dst_peak_inds</span><span class="p">,</span>
            <span class="n">match_line_scores</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_candidates</span><span class="p">(</span><span class="n">edge_inds</span><span class="p">,</span> <span class="n">edge_peak_inds</span><span class="p">,</span> <span class="n">line_scores</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">predicted_instances</span><span class="p">,</span>
            <span class="n">predicted_peak_scores</span><span class="p">,</span>
            <span class="n">predicted_instance_scores</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_instances</span><span class="p">(</span>
            <span class="n">peaks</span><span class="p">,</span>
            <span class="n">peak_vals</span><span class="p">,</span>
            <span class="n">peak_channel_inds</span><span class="p">,</span>
            <span class="n">match_edge_inds</span><span class="p">,</span>
            <span class="n">match_src_peak_inds</span><span class="p">,</span>
            <span class="n">match_dst_peak_inds</span><span class="p">,</span>
            <span class="n">match_line_scores</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_instances</span><span class="p">,</span> <span class="n">predicted_peak_scores</span><span class="p">,</span> <span class="n">predicted_instance_scores</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SLEAP</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/reference.html">Feature Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;20192020, Murthy Lab @ Princeton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>